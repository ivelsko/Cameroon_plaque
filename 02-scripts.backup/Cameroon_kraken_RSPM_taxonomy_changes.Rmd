---
title: "Cameroon plaque taxonomy analysis - Kraken RefSeq database w/ & w/o Pasolli MAGs"
author: "Irina Velsko"
date: "`r format(Sys.time(), '%b %d, %Y')`"
output:
    github_document:
        fig_width: 8
        fig_height: 6
        toc: true
---

```{r load_libraries, echo = F, message = F}
library(knitr)
library(data.table)
library(janitor)
library(taxa)
library(metacoder)
library(plyr)
library(tidyverse)
library(gplots)
library(ggrepel)
library(viridis)
library(cowplot)
opts_chunk$set(echo=F, warning=F, message=F, dpi=150)
```

```{r setup}
knitr::opts_knit$set(root.dir = normalizePath(".."))
```


```{r load_data}
load("./05-results.backup/kraken_refseq_run1.RData") # this has the files with OTU coutns needed to create the taxa environments

# this file has the full taxonomy string for all samples (by hand added in all missing taxonomy from taxize or NCBI taxonomy page online, etc)
all_taxonomy_raw <- fread("./00-documentation.backup/all_taxonomy_filtered_hand.csv")
all_taxonomy <- all_taxonomy_raw %>%
  as_tibble(.) %>%
  mutate(Taxonomy = str_replace_all(Taxonomy, "root", "r__root"),
         Taxonomy = str_replace_all(Taxonomy, "root\\|_", "root\\|"),
         NCBItaxID = str_replace_all(NCBItaxID, "^", "ncbi_")) # this adds ncbi_ in front of all NCBItaxIDs so the column isn't mistaken for numeric and therefore a sample column later


# we won't load the metadata RData object b/c the factors cause problems later b/c of samples that are removed before analysis
metadata <- fread("./00-documentation.backup/01-cameroon_hunter_gatherer_metadata.tsv")

# remove the samples and columns we're not looking at
metadata_mcR <- metadata %>%
  rename(SampleID = `#SampleID`) %>%
  filter(!str_detect(SampleID, "SRR164|10M|EXB|LIB")) %>%
  mutate(Industry = str_replace_all(Industry, "Non-industrial", "NonIndustrial"),
         Market_economy = str_replace_all(Market_economy, "Logging road", "LoggingRoad"),
         Market_economy = str_replace_all(Market_economy, "Forrest camp", "ForrestCamp"),
         Age_group = str_replace_all(Age_group, "18-29", "20s"),
         Age_group = str_replace_all(Age_group, "30-39", "30s"),
         Age_group = str_replace_all(Age_group, "40-49", "40s"),
         Age_group = str_replace_all(Age_group, "50-59", "50s"),
         Age_group = str_replace_all(Age_group, "60+", "60up")) %>% # I think the - and spaces cause problems with coloring the plots)
  select(SampleID, Env, Description, Industry, Ethnic_Group, Village, Market_economy, Age_group, Sex, Tooth_site)

```


Create tables that present the number of read assignments at each taxonomic
level (Phylum, Genus, Species) with the RefSeqOnly and RefSeq+PasolliMAGs
databases, the difference between each, and the fold-difference between the
number of assignments to each taxon. Positive fold-difference means there were
more assignments to that taxon in the RefSeq+PasolliMAGs database, and negative
values means there were more assignments to that taxon in the RefSeqOnly
database.
```{r taxon_differences}

db_phylum_compare <- rso_reports_tax_run1 %>%
  filter(str_detect(SampleID, "CMC")) %>%
  filter(str_detect(Rank, "P")) %>%
  group_by(SampleID, SciName) %>%
  summarize(Rooted_avg = mean(Number_rooted)) %>%
  mutate(Database = "RefSeqOnly") %>%
  select(SciName, SampleID, Database, Rooted_avg) %>%
  bind_rows(., rsmp_reports_tax_run1 %>%
              filter(str_detect(SampleID, "CMC")) %>%
              filter(str_detect(Rank, "P")) %>%
              group_by(SampleID, SciName) %>%
              summarize(Rooted_avg = mean(Number_rooted)) %>%
              mutate(Database = "RefSeqPasolliMAGs") %>%
              select(SciName, SampleID, Database, Rooted_avg)) %>%
  group_by(Database, SciName) %>%
  summarize(Total_rooted = sum(Rooted_avg)) %>%
  spread(Database, Total_rooted) %>%
  select(SciName, RefSeqOnly, RefSeqPasolliMAGs) %>%
  mutate(Read_difference = RefSeqPasolliMAGs - RefSeqOnly, 
         Fold_difference = log2(RefSeqPasolliMAGs/RefSeqOnly)) %>%
  arrange(desc(Fold_difference))

db_genus_compare <- rso_reports_tax_run1 %>%
  filter(str_detect(SampleID, "CMC")) %>%
  filter(str_detect(Rank, "G")) %>%
  group_by(SampleID, SciName) %>%
  summarize(Rooted_avg = mean(Number_rooted)) %>%
  mutate(Database = "RefSeqOnly") %>%
  select(SciName, SampleID, Database, Rooted_avg) %>%
  bind_rows(., rsmp_reports_tax_run1 %>%
              filter(str_detect(SampleID, "CMC")) %>%
              filter(str_detect(Rank, "G")) %>%
              group_by(SampleID, SciName) %>%
              summarize(Rooted_avg = mean(Number_rooted)) %>%
              mutate(Database = "RefSeqPasolliMAGs") %>%
              select(SciName, SampleID, Database, Rooted_avg)) %>%
  group_by(Database, SciName) %>%
  summarize(Total_rooted = sum(Rooted_avg)) %>%
  spread(Database, Total_rooted) %>%
  select(SciName, RefSeqOnly, RefSeqPasolliMAGs) %>%
  mutate(Read_difference = RefSeqPasolliMAGs - RefSeqOnly, 
         Fold_difference = log2(RefSeqPasolliMAGs/RefSeqOnly)) %>%
  arrange(desc(Fold_difference))

db_species_compare <- rso_reports_tax_run1 %>%
  filter(str_detect(SampleID, "CMC")) %>%
  filter(str_detect(Rank, "S")) %>%
  group_by(SampleID, SciName) %>%
  summarize(Rooted_avg = mean(Number_rooted)) %>%
  mutate(Database = "RefSeqOnly") %>%
  select(SciName, SampleID, Database, Rooted_avg) %>%
  bind_rows(., rsmp_reports_tax_run1 %>%
              filter(str_detect(SampleID, "CMC")) %>%
              filter(str_detect(Rank, "S")) %>%
              group_by(SampleID, SciName) %>%
              summarize(Rooted_avg = mean(Number_rooted)) %>%
              mutate(Database = "RefSeqPasolliMAGs") %>%
              select(SciName, SampleID, Database, Rooted_avg)) %>%
  group_by(Database, SciName) %>%
  summarize(Total_rooted = sum(Rooted_avg)) %>%
  spread(Database, Total_rooted) %>%
  select(SciName, RefSeqOnly, RefSeqPasolliMAGs) %>%
  mutate(Read_difference = RefSeqPasolliMAGs - RefSeqOnly, 
         Fold_difference = log2(RefSeqPasolliMAGs/RefSeqOnly)) %>%
  arrange(desc(Fold_difference))


```

There's a lot to look through in the tables above, so to make it easier to
diges, look at the taxa that have at least 100 reads assigned by both databases,
and for which the read difference is at least 100.
```{r taxon_diffs_short, eval = F}
db_species_compare_short <- db_species_compare %>%
  filter(RefSeqOnly >=100, RefSeqPasolliMAGs >= 100, Read_difference >=100 | Read_difference <= -100)

db_genus_compare_short <- db_genus_compare %>%
  filter(RefSeqOnly >=100, RefSeqPasolliMAGs >= 100, Read_difference >=100 | Read_difference <= -100)

db_phylum_compare_short <- db_phylum_compare %>%
  filter(RefSeqOnly >=100, RefSeqPasolliMAGs >= 100, Read_difference >=100 | Read_difference <= -100)

db_species_compare_phage <- db_species_compare %>%
  filter(str_detect(SciName, "phage")) %>%
  filter(!str_detect(SciName, "Bacteria"))

```

Look at the taxonomy of the MAGs from the Pasolli paper taht were added to the
RefSeq database to create our RefSeq+PasolliMAGs database. Where were these taxa
in the taxonomic tree? What are the most abundant taxa at each level (can we
expect increases in assignments of certain taxa b/c there are a lot more of them
in the RSPM database?)
```{r mag_info}
# this is where the Pasolli MAG info is: 
# /projects1/microbiome_calculus/Cameroon_plaque/00-documentation.backup/Pasolli2019_SGBinfo.csv
# maybe parse this?


mag_info <- fread("00-documentation.backup/Pasolli2019_SGBinfo.csv")
mag_info <- as_tibble(mag_info)
mag_info %>% filter(str_detect(closestTaxLevel, "Corynebacterium")) %>% select(-estTaxonomy) %>% arrange(closestTaxLevel) %>% print(., n = 59)

# total counts at each level
mag_info %>%
  group_by(estTaxLevel) %>%
  count()

# counts of each entry at the specified levels
mag_info %>%
  filter(estTaxLevel == "Other") %>%
  select(closestTaxLevel) %>%
  mutate(phylum = sapply(closestTaxLevel, function(f) {
                                  unlist(str_split(f, "\\|"))[2]
                           })) %>%
  filter(!str_detect(phylum, "c__|o__|f__|g__|s__")) %>%
  count(phylum) %>%
  arrange(desc(n)) 
# %>%
#   summarize(total = sum(n))

mag_info %>%
  filter(estTaxLevel == "Family") %>%
  select(closestTaxLevel) %>%
  mutate(family = sapply(closestTaxLevel, function(f) {
                                  unlist(str_split(f, "\\|"))[5]
                           })) %>%
  filter(!str_detect(family, "p__|c__|o__|g__|s__")) %>%
  count(family) %>%
  arrange(desc(n)) 
# %>%
#   summarize(total = sum(n))

mag_info %>%
  filter(estTaxLevel == "Genus") %>%
  select(closestTaxLevel) %>%
  mutate(genus = sapply(closestTaxLevel, function(f) {
                                  unlist(str_split(f, "\\|"))[6]
                           })) %>%
  filter(!str_detect(genus, "p__|c__|o__|f__|s__")) %>%
  count(genus) %>%
  arrange(desc(n)) 
# %>%
#   summarize(total = sum(n))

mag_info %>%
  filter(estTaxLevel == "Species") %>%
  select(closestTaxLevel) %>%
  mutate(species = sapply(closestTaxLevel, function(f) {
                                  unlist(str_split(f, "\\|"))[7]
                           })) %>%
  filter(!str_detect(species, "p__|c__|o__|f__|g__")) %>%
  count(species) %>%
  arrange(desc(n)) 
# %>%
#   summarize(total = sum(n))


```

```{r, eval = F}
table_temp <- fread("./04-analysis/kraken/output/RefSeqPasolliMAGs/SRR514329_S0_L001_R1_000.fastq.combined.fq.prefixed.extractunmapped.bam.fastq.gz.output.1.kraken")

table_temp1 <- table_temp %>%
  filter(V3 == 0, V1 != "U")
```

Let's see if we can get the data into metacoder to visualize how the assignments change around the tree
```{r otu_tables}
# make an OTU table for the RefSeqOnly dataset
rso_otu_table <- rso_reports_tax_run1 %>%
  select(NCBItaxID, SampleID, Number_direct) %>%
  mutate(NCBItaxID = str_replace_all(NCBItaxID, "^", "ncbi_")) %>% # use this for groups instead of cols in metacoder section below. It ensures the NCBItaxID column isn't mistaken for a numeric, and therefore sample, column
  spread(SampleID, Number_direct, fill = 0) %>%
  filter(NCBItaxID != "ncbi_0") %>%
  select(-matches("10M|SRR164|EXB|LIB"))

# make an OTU table for the RefSeq+PasolliMAGs dataset
rsmp_otu_table <- rsmp_reports_tax_run1 %>%
  select(NCBItaxID, SampleID, Number_direct) %>%
  mutate(NCBItaxID = str_replace_all(NCBItaxID, "^", "ncbi_")) %>% # use this for groups instead of cols in metacoder section below. It ensures the NCBItaxID column isn't mistaken for a numeric, and therefore sample, column
  spread(SampleID, Number_direct, fill = 0) %>%
  filter(NCBItaxID != "ncbi_0") %>%
  select(-matches("10M|SRR164|EXB|LIB"))

```

```{r otu_table_tax}

rso_otu_table <- rso_otu_table %>%
  inner_join(., all_taxonomy, by = "NCBItaxID") %>%
  select(NCBItaxID, Taxonomy, everything())

rsmp_otu_table <- rsmp_otu_table %>%
    inner_join(., all_taxonomy, by = "NCBItaxID") %>%
  select(NCBItaxID, Taxonomy, everything())

```


```{r taxa_object_rso}
# parse the taxonomy
rso_obj <- parse_tax_data(rso_otu_table,
                      class_cols = "Taxonomy",
                      class_sep = "|",
                      class_regex = "^(.+)__(.+)$",
                      class_key = c(tax_rank = "taxon_rank", # the first part recognized by the regex; goes into rso_obj$data$class_data$tax_rank and into rso_obj$taxon_ranks
                                    name = "taxon_name")) # the second part recognized by the regex; goes into rso_obj$data$class_data$name

# sum the number of observations of each taxon
# rso_obj$data$tax_abund <- calc_taxon_abund(rso_obj, "tax_data", cols = metadata_mcR$SampleID) # from the Example (https://grunwaldlab.github.io/metacoder_documentation/example.html)
rso_obj$data$tax_abund <- calc_taxon_abund(rso_obj, "tax_data", groups = metadata_mcR$SampleID) # from the FAQ (https://grunwaldlab.github.io/metacoder_documentation/faq.html)

# Add taxon name to tax_abund to see filtering effects easier
rso_obj$data$tax_abund <- rso_obj$data$tax_abund %>%
  mutate(taxon = taxon_names(rso_obj)) %>%
  select(taxon_id, taxon, everything())

rso_obj$data$tax_occ <- calc_n_samples(rso_obj, "tax_abund", groups = metadata_mcR$Industry, cols = rso_otu_table$SampleID)

print(rso_obj)

# Select only the genera
rso_obj_g <- rso_obj %>%
  filter_taxa(n_obs > 10, reassign_obs = c(tax_abund = FALSE)) %>%
  filter_obs("tax_abund", taxon_ranks == "g")

print(rso_obj_g)

# Select only the order
rso_obj_o <- rso_obj %>%
  filter_taxa(n_obs > 10, reassign_obs = c(tax_abund = FALSE)) %>%
  filter_obs("tax_abund", taxon_ranks == "o")

# Remove viruses
rso_obj_noV <- filter_taxa(rso_obj, taxon_names != "Viruses", reassign_obs = c(tax_abund = FALSE)) %>% # or try reassign_obs = FALSE, check also drop_taxa. As it is, there are still viruses in the plots. They just come directly off the root, instead of off a Viruses node
  filter_taxa(n_obs > 10, reassign_obs = c(tax_abund = FALSE))

```

```{r taxa_object_rsmp}
# parse the taxonomy
rsmp_obj <- parse_tax_data(rsmp_otu_table,
                      class_cols = "Taxonomy",
                      class_sep = "|",
                      class_regex = "^(.+)__(.+)$",
                      class_key = c(tax_rank = "taxon_rank", # the first part recognized by the regex; goes into rsmp_obj$data$class_data$tax_rank and into rsmp_obj$taxon_ranks
                                    name = "taxon_name")) # the second part recognized by the regex; goes into rsmp_obj$data$class_data$name

# sum the number of observations of each taxon
# rsmp_obj$data$tax_abund <- calc_taxon_abund(rsmp_obj, "tax_data", cols = metadata_mcR$SampleID) # from the Example (https://grunwaldlab.github.io/metacoder_documentation/example.html)
rsmp_obj$data$tax_abund <- calc_taxon_abund(rsmp_obj, "tax_data", groups = metadata_mcR$SampleID) # from the FAQ (https://grunwaldlab.github.io/metacoder_documentation/faq.html)

# Add taxon name to tax_abund to see filtering effects easier
rsmp_obj$data$tax_abund <- rsmp_obj$data$tax_abund %>%
  mutate(taxon = taxon_names(rsmp_obj)) %>%
  select(taxon_id, taxon, everything())

rsmp_obj$data$tax_occ <- calc_n_samples(rsmp_obj, "tax_abund", groups = metadata_mcR$Industry, cols = rsmp_otu_table$SampleID)

print(rsmp_obj)

# Select only the genera
rsmp_obj_g <- rsmp_obj %>%
  filter_taxa(n_obs > 10, reassign_obs = c(tax_abund = FALSE)) %>%
  filter_obs("tax_abund", taxon_ranks == "g")

print(rsmp_obj_g)

# Select only the order
rsmp_obj_o <- rsmp_obj %>%
  filter_obs("tax_abund", taxon_ranks == "o")

```

```{r metacoder_tree_rso_g}

# Figure out what this is coloring/sizing by
set.seed(1)
rso_obj_g_tree_NI <- heat_tree(rso_obj_g, 
          node_label = rso_obj_g$taxon_names(),
          node_size = rso_obj_g$n_obs(),
          node_color = NonIndustrial,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations
rso_obj_g_tree_NI

# ggsave("05-results.backup/rso_obj_g_tree_NI.pdf", plot = rso_obj_g_tree_NI, device = "pdf",
#        scale = 1, width = 7, height = 5, units = c("in"), dpi = 300)


set.seed(1)
rso_obj_g_tree_I <- heat_tree(rso_obj_g, 
          node_label = rso_obj_g$taxon_names(),
          node_size = rso_obj_g$n_obs(),
          node_color = Industrial,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations
rso_obj_g_tree_I

# ggsave("05-results.backup/rso_obj_g_tree_I.pdf", plot = rso_obj_g_tree_I, device = "pdf",
#        scale = 1, width = 7, height = 5, units = c("in"), dpi = 300)

```

```{r metacoder_tree_rspm_g}

# Figure out what this is coloring/sizing by
set.seed(1)
rsmp_obj_g_NI <- heat_tree(rsmp_obj_g, 
          node_label = rsmp_obj_g$taxon_names(),
          node_size = rsmp_obj_g$n_obs(),
          node_color = NonIndustrial,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations
rsmp_obj_g_NI

# ggsave("05-results.backup/rsmp_obj_g_NI.pdf", plot = rsmp_obj_g_NI, device = "pdf",
#        scale = 1, width = 7, height = 5, units = c("in"), dpi = 300)


set.seed(1)
rsmp_obj_g_I <-heat_tree(rsmp_obj_g, 
          node_label = rsmp_obj_g$taxon_names(),
          node_size = rsmp_obj_g$n_obs(),
          node_color = Industrial,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations
rsmp_obj_g_I

# ggsave("05-results.backup/rsmp_obj_g_I.pdf", plot = rsmp_obj_g_I, device = "pdf",
#        scale = 1, width = 7, height = 5, units = c("in"), dpi = 300)

```

```{r metacoder_tree_rso_o, eval = F}

# Figure out what this is coloring/sizing by
set.seed(1)
heat_tree(rso_obj_o, 
          node_label = rso_obj_o$taxon_names(),
          node_size = rso_obj_o$n_obs(), # n_obs is a function that calculates, in this case, the number of OTUs per taxon
          node_color = NonIndustrial,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations

set.seed(1)
heat_tree(rso_obj_o, 
          node_label = rso_obj_o$taxon_names(),
          node_size = rso_obj_o$n_obs(),
          node_color = Industrial,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations

```

```{r metacoder_tree_rspm_o, eval = F}

# Figure out what this is coloring/sizing by
set.seed(1)
heat_tree(rsmp_obj_o, 
          node_label = rsmp_obj_o$taxon_names(),
          node_size = rsmp_obj_o$n_obs(),
          node_color = NonIndustrial,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations

set.seed(1)
heat_tree(rsmp_obj_o, 
          node_label = rsmp_obj_o$taxon_names(),
          node_size = rsmp_obj_o$n_obs(),
          node_color = Industrial,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations

```

To compare the 2 databases, I think I need to have the OTU tables combined into
one table, with the sample names changed to indicate which database was used. So
add the database to the sample names (_rso, _rsmp) for each and combine the 2
tables into 1. Then make a new metadata table that has the new sample names.
Then combine the 2 into a new taxa object for comparisons.

If you do not have the taxa environment saved, or you modified the input files
to create the environment, run this `combine_data` chunk and the following
`taxa_object_rsomp` chunk. If you have the environment saved, skip these chunks
and run the `filter_rsomp_obj` chunk that comes after.
```{r combine_data, eval = F}
# make an OTU table for the combined RefSeqOnly and RefSeq+PasolliMAGs dataset
rsomp_otu_table <- rso_reports_tax_run1 %>%
  select(NCBItaxID, SampleID, Number_direct) %>%
  mutate(NCBItaxID = str_replace_all(NCBItaxID, "^", "ncbi_"), # use this for groups instead of cols in metacoder section below. It ensures the NCBItaxID column isn't mistaken for a numeric, and therefore sample, column
         SampleID = str_replace_all(SampleID, "$","_rso")) %>% 
  spread(SampleID, Number_direct, fill = 0) %>%
  filter(NCBItaxID != "ncbi_0",
         NCBItaxID != "ncbi_1") %>% # see if this solves the problem of having root twice in mapping heat_tree_matrix
  select(-matches("10M|SRR164|EXB|LIB")) %>%
  # combine RefSeqOnly above with the RefSeq+PasolliMAGs
  full_join(., rsmp_reports_tax_run1 %>%
              select(NCBItaxID, SampleID, Number_direct) %>%
              mutate(NCBItaxID = str_replace_all(NCBItaxID, "^", "ncbi_"), # use this for groups instead of cols in below. It ensures the NCBItaxID column isn't read as a numeric, and therefore sample, column
                     SampleID = str_replace_all(SampleID, "$","_rsmp")) %>% 
              spread(SampleID, Number_direct, fill = 0) %>%
              filter(NCBItaxID != "ncbi_0",
                     NCBItaxID != "ncbi_1") %>%
              select(-matches("10M|SRR164|EXB|LIB"))) %>%
  replace(., is.na(.), 0)

rsomp_otu_table <- rsomp_otu_table %>%
  inner_join(., all_taxonomy, by = "NCBItaxID") %>%
  select(NCBItaxID, Taxonomy, everything())

# combine metadata with new sample names
metadata_both <- metadata_mcR %>%
  mutate(SampleID = str_replace_all(SampleID, "$", "_rso"),
         Database = "RefSeqOnly",
         SampleDB = str_replace(Industry, "$","_rso")) %>%
  bind_rows(., metadata_mcR %>%
              mutate(SampleID = str_replace_all(SampleID, "$","_rsmp"),
                     Database = "RefSeqPasolliMAGs",
                     SampleDB = str_replace(Industry, "$","_rsmp")))

```

```{r taxa_object_rsomp, eval = F}
# parse the taxonomy
rsomp_obj <- parse_tax_data(rsomp_otu_table,
                      class_cols = "Taxonomy",
                      class_sep = "|",
                      class_regex = "^(.+)__(.+)$",
                      class_key = c(tax_rank = "taxon_rank", # the first part recognized by the regex; goes into rsomp_obj$data$class_data$tax_rank and into rsomp_obj$taxon_ranks
                                    name = "taxon_name")) # the second part recognized by the regex; goes into rsomp_obj$data$class_data$name

# sum the number of observations of each taxon
rsomp_obj$data$tax_abund <- calc_taxon_abund(rsomp_obj, "tax_data", groups = metadata_both$SampleID) # from the FAQ (https://grunwaldlab.github.io/metacoder_documentation/faq.html)

# Add taxon name to tax_abund to see filtering effects easier
rsomp_obj$data$tax_abund <- rsomp_obj$data$tax_abund %>%
  mutate(taxon = taxon_names(rsomp_obj)) %>%
  select(taxon_id, taxon, everything())

rsomp_obj$data$tax_occ <- calc_n_samples(rsomp_obj, "tax_abund", groups = metadata_both$SampleDB, cols = rsomp_otu_table$SampleID)

# print(rsomp_obj)

# save(rsomp_obj, file = "./05-results.backup/kraken_RSOMP_taxa_envt.RData")

```

# Start here to work on this tomorrow
Let's follow the Human microbiome example on the metacodeR page (https://grunwaldlab.github.io/metacoder_documentation/publication--05--16s_human_microbiome.html)
```{r metacoder_example}
# analysis parameters
matrix_plot_depth <- 6 # The maximum number of ranks to display
color_interval <- c(-4, 4) # The range of values (log 2 ratio of median proportion) to display
min_read_count <- 100 # The minium number of reads needed for a taxon to be graphed

# parse the taxonomy
rsomp_obj_test <- parse_tax_data(rsomp_otu_table,
                      class_cols = "Taxonomy",
                      class_sep = "|",
                      class_regex = "^(.+)__(.+)$",
                      class_key = c(tax_rank = "taxon_rank", # the first part recognized by the regex; goes into rsomp_obj_test$data$class_data$tax_rank and into rsomp_obj_test$taxon_ranks
                                    name = "taxon_name")) # the second part recognized by the regex; goes into rsomp_obj_test$data$class_data$name

names(rsomp_obj_test$data) <- c("otu_count","taxonomy_data") # Rename abundnace matrix to something more understandable

# filter the taxonomy
rsomp_obj_test <- filter_taxa(rsomp_obj_test, !grepl(taxon_names, pattern =  "Viruses")) # filter out Virus, viridae, virinae
rsomp_obj_test <- filter_taxa(rsomp_obj_test, !grepl(taxon_names, pattern =  "viridae")) # filter out Virus, viridae, virinae
rsomp_obj_test <- filter_taxa(rsomp_obj_test, !grepl(taxon_names, pattern =  "virinae")) # filter out Virus, viridae, virinae
rsomp_obj_test <- filter_taxa(rsomp_obj_test, !grepl(taxon_names, pattern =  "virus")) # filter out Virus, viridae, virinae

# convert counts to proportions
rsomp_obj_test$data$otu_prop <- calc_obs_props(rsomp_obj_test,
                                               data = "otu_count",
                                               cols = metadata_both$SampleID)


# calculate abundance per taxon 
rsomp_obj_test$data$otu_abund <- calc_taxon_abund(rsomp_obj_test, 
                                                  "otu_prop", 
                                                  cols = metadata_both$SampleID)


# add a new tibble with the abundance of each taxon to the environment
rsomp_obj_test <- rsomp_obj_test %>%
  mutate_obs("otu_abund", abundance = rowMeans(rsomp_obj_test$data$otu_abund[metadata_both$SampleID]))

# plot everything
set.seed(1)
plot_all <- rsomp_obj_test %>%
  filter_taxa(abundance >= 0.001) %>%
  filter_taxa(taxon_names != "") %>% # Some taxonomic levels are not named
  heat_tree(node_size = n_obs,
            # node_size_range = c(0.01, 0.06),
            node_size_axis_label = "Number of OTUs",
            node_color = abundance,
            node_color_axis_label = "Mean proportion of reads",
            node_label = taxon_names)
plot_all

```

Calculate differences between the databases and plot showing that
```{r metacoder_ex_cont_database_diff_plots}

rsomp_obj_test$data$diff_table <- compare_groups(rsomp_obj_test,
                                           data = "otu_abund",
                                           cols = metadata_both$SampleID,
                                           groups = metadata_both$SampleDB)
                                           
rsomp_obj_test <- mutate_obs(rsomp_obj_test, "diff_table",
                       wilcox_q_value = p.adjust(wilcox_p_value, method = "fdr"),
                       log2_median_ratio = ifelse(wilcox_q_value < 0.05 | is.na(wilcox_q_value), log2_median_ratio, 0))
                       
plot_database_diff <- function(site_1, site_2, seed = 1) {
  set.seed(seed)
  rsomp_obj_test %>%
    # mutate_obs("tax_prop", abundance = rowMeans(rsomp_obj_test$data$tax_prop[sample_data$sample_id])) %>%
    filter_taxa(abundance >= 0.001, reassign_obs = FALSE) %>%
    filter_taxa(taxon_names != "", reassign_obs = FALSE) %>% # Some taxonomic levels are not named
    filter_obs("diff_table", treatment_1 %in% c(site_1, site_2), treatment_2 %in% c(site_1, site_2)) %>%
    heat_tree(node_size_axis_label = "Number of OTUs",
              node_size = n_obs,
              node_color_axis_label = "Log 2 ratio of median proportions",
              node_color = log2_median_ratio,
              node_color_range = diverging_palette(),
              node_color_trans = "linear",
              node_color_interval = c(-5, 5),
              edge_color_interval = c(-5, 5),
              node_label = taxon_names)
}

rso_vs_rsmp_NI <- plot_database_diff("NonIndustrial_rsmp", "NonIndustrial_rso")
rso_vs_rsmp_I <- plot_database_diff("Industrial_rsmp", "Industrial_rso")
rso_NI_vs_I <- plot_database_diff("NonIndustrial_rso", "Industrial_rso")
rsmp_NI_vs_I <- plot_database_diff("NonIndustrial_rsmp", "Industrial_rsmp")

# ggsave("05-results.backup/rso_vs_rsmp_NI.pdf", plot = rso_vs_rsmp_NI, device = "pdf",
#        scale = 1, width = 7, height = 5, units = c("in"), dpi = 300)
# 
# ggsave("05-results.backup/rso_vs_rsmp_I.pdf", plot = rso_vs_rsmp_I, device = "pdf",
#        scale = 1, width = 7, height = 5, units = c("in"), dpi = 300)
# 
# ggsave("05-results.backup/rso_NI_vs_I.pdf", plot = rso_NI_vs_I, device = "pdf",
#        scale = 1, width = 7, height = 5, units = c("in"), dpi = 300)
# 
# ggsave("05-results.backup/rsmp_NI_vs_I.pdf", plot = rsmp_NI_vs_I, device = "pdf",
#        scale = 1, width = 7, height = 5, units = c("in"), dpi = 300)

```




Load the saved environment. 
```{r filter_rsomp_obj}
load("./05-results.backup/kraken_RSOMP_taxa_envt.RData") # this is the saved taxa environment so you don't have to wait to generate it

```

Filter out viruses.
```{r rsomp_filter_viruses}
# Remove viruses
rsomp_obj_noV <- filter_taxa(rsomp_obj, taxon_names != "Viruses", reassign_obs = c(tax_abund = FALSE)) %>% # or try reassign_obs = FALSE, check also drop_taxa. As it is, there are still viruses in the plots. They just come directly off the root, instead of off a Viruses node
  filter_taxa(n_obs > 10, reassign_obs = c(tax_abund = FALSE))
# %>%
#   filter_obs("tax_abund", taxon_ranks == "g", reassign_obs = c(tax_abund = FALSE)) # adding this makes it not work

# Calculate the differences in abundance of taxa between the databases for Industrial and NonIndustrial groups
rsomp_obj_noV$data$diff_table <- compare_groups(rsomp_obj_noV,
                                      dataset = "tax_abund",
                                      cols = metadata_both$SampleID, # What columns of sample data to use
                                      groups = metadata_both$SampleDB) # What category each sample is assigned to

# print(rsomp_obj_noV$data$diff_table)


```


Filter at different taxonomic levels.
```{r rsomp_filter_levels}

# # Select only the family
# rsomp_obj_f <- rsomp_obj %>%
#   filter_taxa(n_obs > 10, reassign_obs = c(tax_abund = FALSE)) %>%
#   filter_obs("tax_abund", taxon_ranks == "f")

# Select only the genera
rsomp_obj_g <- rsomp_obj %>%
  filter_taxa(n_obs > 10, reassign_obs = c(tax_abund = FALSE)) %>%
  filter_obs("tax_abund", taxon_ranks == "g")

# print(rsomp_obj_g)

# this is from the metacodeR package and I'm using it to testing the filtering
# Parse data for example
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")
                   
# Calculate the taxon abundance for each numeric column (i.e. sample)
x$data$tax_abund <- calc_taxon_abund(x, "tax_data", groups = hmp_samples$sex)

# Add taxon name to tax_abund to see filtering effects easier
x$data$tax_abund <- x$data$tax_abund %>%
  mutate(taxon = taxon_names(x)) %>%
  select(taxon_id, taxon, everything())


x %>%
  filter_taxa(n_obs > 10, reassign_obs = c(tax_abund = FALSE)) %>%
  filter_obs("tax_abund", taxon_ranks == "g")


```


```{r rsomp_test_trees}

set.seed(1)
rsomp_obj_noV_tree_g_rso <- heat_tree(rsomp_obj_g, 
          node_label = rsomp_obj_g$taxon_names(),
          node_size = rsomp_obj_g$n_obs(),
          node_color = NonIndustrial_rso,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations
rsomp_obj_noV_tree_NI_rso

ggsave("05-results.backup/rsomp_obj_noV_tree_NI_rso.pdf", plot = rsomp_obj_noV_tree_NI_rso, device = "pdf",
       scale = 1, width = 7, height = 5, units = c("in"), dpi = 300)

set.seed(1)
rsomp_obj_noV_tree_g_rsmp <- heat_tree(rsomp_obj_g, 
          node_label = rsomp_obj_g$taxon_names(),
          node_size = rsomp_obj_g$n_obs(),
          node_color = NonIndustrial_rsmp,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations
rsomp_obj_noV_tree_NI_rsmp

# ggsave("05-results.backup/rsomp_obj_noV_tree_NI_rsmp.pdf", plot = rsomp_obj_noV_tree_NI_rsmp, device = "pdf",
#        scale = 1, width = 7, height = 5, units = c("in"), dpi = 300)

```

```{r group_differences}

set.seed(1)
heat_tree(rsomp_obj_noV, 
          node_label = taxon_names,
          node_size = n_obs, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
          node_color = log2_median_ratio, # A column from `obj$data$diff_table`
          node_color_interval = c(-2, 2), # The range of `log2_median_ratio` to display
          node_color_range = c("cyan", "gray", "tan"), # The color palette used
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Log 2 ratio of median proportions",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations


set.seed(1)
heat_tree_matrix(rsomp_obj_noV,
                 data = "diff_table",
                 node_size = n_obs, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
                 node_label = taxon_names,
                 node_color = log2_median_ratio, # A column from `obj$data$diff_table`
                 node_color_range = diverging_palette(), # The built-in palette for diverging data
                 node_color_trans = "linear", # The default is scaled by circle area
                 node_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
                 edge_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
                 node_size_axis_label = "Number of OTUs",
                 node_color_axis_label = "Log2 ratio median proportions",
                 layout = "davidson-harel", # The primary layout algorithm
                 initial_layout = "reingold-tilford", # The layout algorithm that initializes node locations
                 output_file = "differential_heat_tree_g.pdf") # Saves the plot as a pdf file

```


































